package de.infolektuell.gradle.jextract.extensions;

import de.infolektuell.gradle.jextract.tasks.LibraryPathProvider;
import org.gradle.api.Action;
import org.gradle.api.NamedDomainObjectSet;
import org.gradle.api.file.Directory;
import org.gradle.api.file.SourceDirectorySet;
import org.gradle.api.model.ObjectFactory;
import org.gradle.api.provider.SetProperty;
import org.jspecify.annotations.NonNull;

import javax.inject.Inject;
import java.util.regex.Pattern;

/**
 * Configures a source Set to include libraries generated by Jextract
 */
public abstract class SourceSetExtension {
    /**
     * The name of this extension how it is accessible from build.gradle or build.gradle.kts
     */
    public static final String EXTENSION_NAME = "jextract";

    private final String name;
    private final Pattern firstCharPattern = Pattern.compile("^.");
    private final NamedDomainObjectSet<@NonNull LibraryHandler> libraries;
    private final SourceDirectorySet headers;
    private final SourceDirectorySet binaries;
    private final LibraryPathProvider libraryPath;

    @Inject
    public SourceSetExtension(String name) {
        super();
        this.name = name;
        this.libraries = getObjects().namedDomainObjectSet(LibraryHandler.class);
        this.headers = getObjects().sourceDirectorySet("headers", "Native Header Files");
        this.binaries = getObjects().sourceDirectorySet("binaries", "Native binary Files");
        this.libraryPath = getObjects().newInstance(LibraryPathProvider.class);
    }

    /**
     * Libraries that were defined in the jextract extension. Their generated source and class outputs will be added to the source set.
     */
    public final NamedDomainObjectSet<@NonNull LibraryHandler> getLibraries() {
        return this.libraries;
    }

    /**
     * Configures the libraries that were defined in the jextract extension. Their generated source and class outputs will be added to the source set.
     */
    public final void libraries(Action<@NonNull NamedDomainObjectSet<@NonNull LibraryHandler>> action) {
        action.execute(this.libraries);
    }

    public SourceDirectorySet getHeaders() { return headers; }
    public SourceDirectorySet getBinaries() { return binaries; }
    public LibraryPathProvider getLibraryPath() { return libraryPath; }

    /**
     * Directories containing legal notice documents that can be included in the generated JMOD archive.
     * @return A set property to add the directories.
     */
    public abstract SetProperty<@NonNull Directory> getLegalNotices();

    public String getNativeImplementationConfigurationName() { return getConfigurationName("nativeImplementation", ""); }
    public String getArchiveHeaderFilesConfigurationName() { return getConfigurationName("archive", "headerFiles"); }
    public String getArchiveBinaryConfigurationName() { return getConfigurationName("archive", "binaries"); }

    @Inject protected abstract ObjectFactory getObjects();

    private String getConfigurationName(String scope, String target) {
        final String capitalizedTarget = firstCharPattern.matcher(target).replaceFirst(m -> m.group().toUpperCase());
        if (this.name.equals("main")) return scope + capitalizedTarget;
        final String capitalizedScope = firstCharPattern.matcher(scope).replaceFirst(m -> m.group().toUpperCase());
        return this.name + capitalizedScope + capitalizedTarget;
    }
}

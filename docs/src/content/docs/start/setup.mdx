---
title: Setup Guide
description: A getting started guide to setup the Gradle Jextract plugin
sidebar:
  order: 2
---

This setup guide covers the standard use-case of generating and integrating native bindings into a Java project with a main source set.

## Prerequisites

You should have these things in place before you start:

- JVM 17 or above
- A Gradle project using Gradle v8.8 or above

## Including the Plugin

This will configure the project to download and use Jextract 22 which is determined from the Java toolchain.

:::tip
See the [latest version](https://plugins.gradle.org/plugin/de.infolektuell.jextract) on Gradle plugin portal.
:::

<Tabs syncKey="dsl">
<TabItem label="Kotlin">

```kts
// build.gradle.kts
plugins {
    `java-library`
    id("de.infolektuell.jextract") version "x.y.z"
}

repositories {
    mavenCentral()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(22)
    }
}
```

</TabItem>
<TabItem label="Groovy">

```groovy
// build.gradle
plugins {
    id 'java-library'
    id 'de.infolektuell.jextract' version 'x.y.z'
}

repositories {
    mavenCentral()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of 22
    }
}
```

</TabItem>
</Tabs>

## Adding a Library

Libraries often consist of a `name.h` file and binaries like `libname.dylib` or `name.dll`.
Put them in your source folder like this:

<FileTree>

- lib
  - src
    - main
      - java
        - com
          - example
            - greeting
              - greeting.java
      - native
        - macos
          - **libgreeting.dylib** the macOS binary
        - windows
          - **greeting.dll** the windows binary
      - public
        - **greeting.h** the header file
  - build.gradle.kts
- settings.gradle.kts

</FileTree>

## Configuring the plugin

Configure the plugin via DSL extension, so it can find the library files.

<Tabs syncKey="dsl">
<TabItem label="Kotlin">

```kts
// build.gradle.kts
jextract.libraries {
    val greeting by registering {
        header = layout.projectDirectory.file("src/main/public/greeting.h")
        headerClassName = "Greeting"
        targetPackage = "com.example.greeting"
    }
    sourceSets.named("main") {
        jextract.libraries.addLater(greeting)
    }
}
```

</TabItem>
<TabItem label="Groovy">

```groovy
// build.gradle
jextract.libraries {
    def greeting = register('greeting') {
        header = layout.projectDirectory.file("src/main/public/greeting.h")
        headerClassName = "Greeting"
        targetPackage = "com.example.greeting"
    }
    sourceSets.named("main") {
        jextract.libraries.addLater(greeting)
    }
}
```

</TabItem>
</Tabs>

## Build and use

Now the project is ready for its first build.

<Tabs syncKey="os">
<TabItem label="Windows">

```shell title="Building the project"
gradlew.bat build
```

</TabItem>
<TabItem label="Linux">

```shell title="Building the project"
./gradlew build
```

</TabItem>
</Tabs>

This will result in the following output file structure:

<FileTree>

- .gradle
  - **jextract** Cache for Jextract downloads and installations
    - downloads
    - installation
- lib
  - build
    - ...
    - generated
      - sources
        - jextract
          - **greeting** the library bindings
            - com
              - example
                - greeting
                  - **Greeting.java** the bindings to import and use in Java code
    - ...
  - build.gradle.kts
- settings.gradle.kts

</FileTree>

## Loading libraries

There are mainly two approaches how the generated code can load and access the correct binaries.
Please see this [stackoverflow question] for more details and explanation.

### Automatic Loading

The code searches in the OS-specific paths for the binary files and tries to load them via `system.loadLibrary`.
The `java.library.path` property can be augmented to search in more paths or in the deployed app distribution.
This approach is activated in a library config in the plugin DSL.

<Tabs syncKey="dsl">
<TabItem label="Kotlin">

```kts {4-5}
// build.gradle.kts
jextract.libraries {
    val greeting by registering {
        useSystemLoadLibrary = true
        libraries.add("greeting")
    }
}
```

</TabItem>
<TabItem label="Groovy">

```groovy {4-5}
// build.gradle
jextract.libraries {
    def greeting = register('greeting') {
        useSystemLoadLibrary = true
        libraries.add("greeting")
    }
}
```

</TabItem>
</Tabs>

:::note
`system.loadLibrary` infers the conventional name for an OS-Specific dynamic library from the base name, e.g. greeting.dll, libgreeting.dylib, or libgreeting.so.
:::

### Manual Loading

Instead of configuring the libraries in the DSL, custom logic for loading the files can be implemented.
This is a typical approach for bundling natives as resources of a jar file for more portable deployment.

:::tip[Sample Project]
The [example project] demonstrates this approach.
:::

[stackoverflow question]: https://stackoverflow.com/questions/78528174/gradle-java-include-native-library-project-panama
[example project]: https://github.com/infolektuell/gradle-jextract/tree/main/examples/
